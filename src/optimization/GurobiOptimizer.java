package optimization; import gurobi.*; import model.Product; import model.Shelf; import analysis.TrafficPredictor; import java.util.*; public class GurobiOptimizer { private final List<Shelf> shelves; private final List<Product> products; private final TrafficPredictor trafficPredictor; public GurobiOptimizer(List<Shelf> shelves, List<Product> products, TrafficPredictor trafficPredictor) { this.shelves = shelves; this.products = products; this.trafficPredictor = trafficPredictor; } public OptimizationResult solve(Map<Integer, Integer> inputAllocation, double minSpaceFlexibility) { try (GRBEnv env = new GRBEnv(); GRBModel model = new GRBModel(env)) { model.set(GRB.StringAttr.ModelName, "RetailSpaceAllocation"); model.set(GRB.DoubleParam.TimeLimit, 36000.0); model.set(GRB.IntParam.OutputFlag, 1); int numShelves = shelves.size(); int numProducts = products.size(); GRBVar[][] xVars = new GRBVar[numShelves][numProducts]; GRBVar[][] sVars = new GRBVar[numShelves][numProducts]; for (int b = 0; b < numShelves; b++) { for (int p = 0; p < numProducts; p++) { xVars[b][p] = model.addVar(0.0, 1.0, 0.0, GRB.BINARY, "x_" + b + "_" + p); sVars[b][p] = model.addVar(0.0, shelves.get(b).getCapacity(), 0.0, GRB.CONTINUOUS, "s_" + b + "_" + p); } } GRBQuadExpr objective = new GRBQuadExpr(); Map<Integer, Double> theta_b = new HashMap<>(); for (Shelf shelf : shelves) { theta_b.put(shelf.getId(), trafficPredictor.predictTrafficDensity(shelf, products, inputAllocation)); } for (int b = 0; b < numShelves; b++) { Shelf shelf = shelves.get(b); double C_b = shelf.getCapacity(); double theta_b_val = theta_b.get(shelf.getId()); for (int p = 0; p < numProducts; p++) { Product product = products.get(p); double rho_p = product.getProfitMargin(); double i_p = product.getImpulseRate(); GRBQuadExpr term = new GRBQuadExpr(); term.addTerm(rho_p * i_p * C_b * theta_b_val, sVars[b][p], xVars[b][p]); objective.add(term); } } model.setObjective(objective, GRB.MAXIMIZE); for (int b = 0; b < numShelves; b++) { GRBLinExpr shelfSum = new GRBLinExpr(); for (int p = 0; p < numProducts; p++) { shelfSum.addTerm(1.0, xVars[b][p]); } model.addConstr(shelfSum, GRB.LESS_EQUAL, 1.0, "OneProductPerShelf_" + b); } for (int p = 0; p < numProducts; p++) { GRBLinExpr productSum = new GRBLinExpr(); for (int b = 0; b < numShelves; b++) { productSum.addTerm(1.0, xVars[b][p]); } model.addConstr(productSum, GRB.LESS_EQUAL, 1.0, "OneShelfPerProduct_" + p); } for (int b = 0; b < numShelves; b++) { GRBLinExpr spaceUsed = new GRBLinExpr(); for (int p = 0; p < numProducts; p++) { spaceUsed.addTerm(1.0, sVars[b][p]); } model.addConstr(spaceUsed, GRB.LESS_EQUAL, shelves.get(b).getCapacity(), "Capacity_" + b); } for (int b = 0; b < numShelves; b++) { for (int p = 0; p < numProducts; p++) { Product product = products.get(p); double minSpace = Math.max(1.0, product.getSalesVolume() / 1000.0 * (1.0 - minSpaceFlexibility)); double maxSpace = minSpace * 1.2; model.addConstr(sVars[b][p], GRB.LESS_EQUAL, maxSpace * xVars[b][p], "s_ub_" + b + "_" + p); model.addConstr(sVars[b][p], GRB.GREATER_EQUAL, minSpace * xVars[b][p], "s_lb_" + b + "_" + p); } } model.optimize(); double optimizedObjective = model.get(GRB.DoubleAttr.ObjVal); Map<Integer, Integer> optimizedAllocation = new HashMap<>(); Map<Integer, Double> allocatedSpace = new HashMap<>(); for (int b = 0; b < numShelves; b++) { for (int p = 0; p < numProducts; p++) { if (xVars[b][p].get(GRB.DoubleAttr.X) > 0.5) { optimizedAllocation.put(shelves.get(b).getId(), products.get(p).getId()); allocatedSpace.put(shelves.get(b).getId(), sVars[b][p].get(GRB.DoubleAttr.X)); break; } } } double currentObjective = calculateNonlinearObjective(inputAllocation); return new OptimizationResult(optimizedAllocation, allocatedSpace, optimizedObjective, currentObjective, (optimizedObjective - currentObjective) / currentObjective * 100, model.get(GRB.DoubleAttr.Runtime)); } catch (GRBException e) { System.err.println("Gurobi error: " + e.getMessage()); e.printStackTrace(); return null; } } private double calculateNonlinearObjective(Map<Integer, Integer> allocation) { double total = 0.0; for (Map.Entry<Integer, Integer> entry : allocation.entrySet()) { int shelfId = entry.getKey(); int productId = entry.getValue(); Shelf shelf = shelves.stream().filter(s -> s.getId() == shelfId).findFirst().orElse(null); Product product = products.stream().filter(p -> p.getId() == productId).findFirst().orElse(null); if (shelf == null || product == null) continue; double rho_p = product.getProfitMargin(); double i_p = product.getImpulseRate(); double s_pb = product.getSalesVolume() / 1000.0; double C_b = shelf.getCapacity(); double x_bg = 1.0; double theta_b = 0.5; total += rho_p * i_p * s_pb * C_b * x_bg * theta_b; } return total; } }
